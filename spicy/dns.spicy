# Copyright (c) 2021 by the Zeek Project. See LICENSE for details.

module DNS;

print "in the dns module";

import spicy;

type RRType = enum {
    A = 1, NS = 2, MD = 3, MF = 4, CNAME = 5, SOA = 6, MB = 7, MG = 8, MR = 9,
    NULL = 10, WKS = 11, PTR = 12, HINFO = 13, MINFO = 14, MX = 15, TXT = 16,
    AAAA = 28, NBS = 32, SRV= 33, A6 = 38, EDNS = 41 };

public type PDU = unit {
    id    : uint16;
    flags : bytes &size=2;

    qdcount: uint16;
    ancount: uint16;
    nscount: uint16;
    arcount: uint16;

    question:   Question[self.qdcount];
    answer:     ResourceRecord[self.ancount];
    authority:  ResourceRecord[self.nscount];
    additional: ResourceRecord[self.arcount];
    
    on %done { print self; }
};

type Question = unit {
    qname:  Name;
    qtype:  uint16;
    qclass: uint16;
};

type ResourceRecord = unit() {
    name:   Name;
    type_:     uint16 &convert=RRType($$);
    class:  uint16;
    ttl:    uint32;
    rdlen:  uint16;

    switch ( self.type_ ) {
        RRType::NS, RRType::CNAME, RRType::PTR
                     -> rr_body_rname:   Name;
        RRType::A    -> rr_body_a:       addr &ipv4;
        RRType::AAAA -> rr_body_a:       addr &ipv6;
        RRType::MX   -> rr_body_mx:      RDataMX;
        RRType::SOA  -> rr_body_soa:     RDataSOA;
        RRType::SRV  -> rr_body_srv:     RDataSRV;
        RRType::TXT  -> rr_body_txt:     CharacterString;
        *            -> rdata:   bytes &size=self.rdlen;
    };
};

type RDataMX = unit {
    preference: uint16;
    name:        Name;
};

type RDataSOA = unit {
    mname:      Name;
    rname:      Name;
    serial:     uint32;
    refresh:    uint32 &convert=cast<interval>($$);
    retry:      uint32 &convert=cast<interval>($$);
    expire:     uint32 &convert=cast<interval>($$);
    minimum:    uint32 &convert=cast<interval>($$);
};

type RDataSRV = unit {
    priority_:  uint16;
    weight:     uint16;
    port_:      uint16;
    target:     Name;
};

type CharacterString = unit {
    len: uint8;
    data: bytes &size=(self.len);
};

type Name = unit {
    words: Label[] &until=($$.len.offset == 0 || $$.len.compressed != 0);
};

type Pointer = unit() {
    len: bitfield(16) {
        offset: 0..13;
        };
    };

type Label = unit() {
    len: bitfield(8) {
        offset: 0..5;
        compressed: 6..7;
    };

    switch ( self.len.compressed ) {
        0 ->    label: bytes &size=self.len.offset;
        3 ->    ptr: uint8;
    };
};
