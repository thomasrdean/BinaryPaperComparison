# Copyright (c) 2021 by the Zeek Project. See LICENSE for details.

module DNS;

import spicy;

type RRType = enum {
    A = 1, NS = 2, MD = 3, MF = 4, CNAME = 5, SOA = 6, MB = 7, MG = 8, MR = 9,
    NULL = 10, WKS = 11, PTR = 12, HINFO = 13, MINFO = 14, MX = 15, TXT = 16,
    AAAA = 28, NBS = 32, SRV= 33, A6 = 38, EDNS = 41 };

public type Message = unit {
    %random-access;

    id    : uint16;
    flags : bitfield(16) {
            qr: 0;
            opcode: 1..4;
            aa: 5;
            tc: 6;
            rd: 7;
            ra: 8;
            z:  9..11;
            rcode: 12..15;
        } &bit-order = spicy::BitOrder::MSB0;

    qdcount: uint16;
    ancount: uint16;
    nscount: uint16;
    arcount: uint16;

    question:   (Question(self))[self.qdcount];
    answer:     (ResourceRecord(self, RRType::ANSWER))[self.ancount];
    authority:  (ResourceRecord(self, RRType::AUTH))[self.nscount];
    additional: (ResourceRecord(self, RRType::ADDL))[self.arcount];
};

type Question = unit() {
    qname:  Name();
    qtype:  uint16;
    qclass: uint16;
};

type ResourceRecord = unit() {
    name:   Name(msg);
    type_:     uint16 &convert=RRType($$);

    switch ( self.type_ ) {
        RRType::NS, RRType::CNAME, RRType::PTR
                     -> rr_body_rname:   Name(msg);
        RRType::A    -> rr_body_a:       addr &ipv4;
        RRType::AAAA -> rr_body_a:       addr &ipv6;
        RRType::MX   -> rr_body_mx:      RDataMX(msg);
        RRType::SOA  -> rr_body_soa:     RDataSOA(msg);
        RRType::SRV  -> rr_body_srv:     RDataSRV(msg);
        RRType::TXT  -> rr_body_txt:     (CharacterString(msg))[self.rdlen];
    };
};

type RDataMX = unit(msg: Message) {
    preference: uint16;
    name:        Name(msg);
};

type RDataSOA = unit(msg: Message) {
    mname:      Name(msg);
    rname:      Name(msg);
    serial:     uint32;
    refresh:    uint32 &convert=cast<interval>($$);
    retry:      uint32 &convert=cast<interval>($$);
    expire:     uint32 &convert=cast<interval>($$);
    minimum:    uint32 &convert=cast<interval>($$);
};

type RDataSRV = unit(msg: Message) {
    priority_:  uint16;
    weight:     uint16;
    port_:      uint16;
    target:     Name(msg);
};

type CharacterString = unit(msg: Message) {
    len: uint8;
    data: bytes &size=(self.len);
};

type Name = unit(msg: Message) {
    : (Label(msg, self))[] &until=($$.len.offset == 0 || $$.len.compressed != 0);

    var label: bytes = b"";
};

type Pointer = unit(msg: Message, label: Label) {
    len: bitfield(16) {
        offset: 0..13;
        };

    name: Name(msg) &parse-at=(msg.input() + self.len.offset);
    };

type Label = unit(msg: Message, inout name: Name) {
    %random-access;

    len: bitfield(8) {
        offset: 0..5;
        compressed: 6..7;
        };

    switch ( self.len.compressed ) {
        0 ->    label: bytes &size=self.len.offset {
                    if ( |self.label| ) {
                        name.label += b".";
                        name.label += self.label;
                        }
                    }

        3 ->    ptr: Pointer(msg, self) &parse-at=self.input() {
                    name.label += self.ptr.name.label;
                    self.adjust = 2; # Consume the additional byte in %done.
                    }
    };

    on %done {
        if ( self.adjust > 0 )
            self.set_input(self.input() + self.adjust);
    }

    var adjust: uint64 = 0;
};
