# Copyright (c) 2021 by the Zeek Project. See LICENSE for details.

module DNS;

import spicy;

public type PDU = unit {
    transactionId    : uint16;
    flags : bytes &size=2;

    numQuestion: uint16;
    numAnswer: uint16;
    numAuthority: uint16;
    numAdditional: uint16;

    question:   Query[self.numQuestion];
    answer:     ResourceRecord[self.numAnswer];
    authority:  ResourceRecord[self.numAuthority];
    additional: ResourceRecord[self.numAdditional];
    
    extraBytes: bytes &eod;
    on %done { print self; }
} &requires = |self.extraBytes| == 0;

type Query = unit {
    name:  Domain;
    type_:  uint16;
    class: uint16;
};

type ResourceRecord = unit() {
    name:   Domain;
    type_:  uint16 &convert=RRType($$);
#    class:  uint16;
#    ttl:    uint32;
#    dataLength:  uint16;

    switch ( self.type_ ) {
        RRType::A    -> bodyA: RRBodyA;
        RRType::AAAA -> bodyAAAA: RRBodyAAAA;
        RRType::CNAME-> bodyCNAME: RRBodyCNAME;
        RRType::SOA  -> bodySOA: RRBodySOA;
        RRType::TXT  -> bodyTXT: RRBodyTXT;
        RRType::OPT  -> bodyOPT: RRBodyOPT;
        RRType::NS   -> bodyNS: RRBodyNS;
        RRType::KEY  -> bodyKEY: RRBodyKEY;
        RRType::SIG  -> bodyRRSIG: RRBodyRRSIG;
        RRType::DS   -> bodyDS: RRBodyDS;
        RRType::NSEC3 -> bodyNSEC3: RRBodyNSEC3;
        *            -> rdata:   bytes &size=0; # todo: throw error here?
    };
};

type RRType = enum {
    A = 1,
    AAAA = 28,
    CNAME = 5,
    SOA = 6,
    TXT = 16,
    OPT = 41,
    NS = 2,
    KEY = 48,
    SIG = 46,
    DS = 43,
    NSEC3 = 50,

    PTR = 12,
    MX = 15,
};

type Domain = unit {
    words: Word[] &until=($$.len.offset == 0 || $$.len.compressed != 0);
};

type Word = unit() {
    len: bitfield(8) {
        offset: 0..5;
        compressed: 6..7;
    };

    switch ( self.len.compressed ) {
        0 ->    label: bytes &size=self.len.offset;
        3 ->    ptr: uint8;
    };
};

type Map = unit() {
    mapNum: uint8;
    length: uint8;
    mapbits: bytes &size=self.length;
};

type RRBodyA = unit() {
    class_: uint16;
    timeToLive: uint32;
    dataLength: uint16;
    address: addr &ipv4;
};
type RRBodyAAAA = unit() {
    class_: uint16;
    timeToLive: uint32;
    dataLength: uint16;
    address: addr &ipv6;
};
type RRBodyCNAME = unit() {
    class_: uint16;
    timeToLive: uint32;
    dataLength: uint16;
    cname: Domain;
};
type RRBodySOA = unit() {
    class_: uint16;
    timeToLive: uint32;
    dataLength: uint16;
    primaryNameServer: Domain;
    reponsibleAuthority: Domain;
    serialNumber: uint32;
    refreshInterval: uint32;
    retryInterval: uint32;
    expireLimit: uint32;
    minimumTTL: uint32;
};
type RRBodyTXT = unit() {
    class_: uint16;
    timeToLive: uint32;
    dataLength: uint16;
    text: bytes &size=self.dataLength;
};
type RRBodyOPT = unit() {
    udpPayloadSize: uint16;
    higherBitsInExtendedRcode: uint8;
    EDNS0Version: uint8;
    z: uint16;
    dataLength: uint16;
};
type RRBodyNS = unit() {
    class_: uint16;
    timeToLive: uint32;
    dataLength: uint16;
    nameServer: Domain;
};
type RRBodyKEY = unit() {
    class_: uint16;
};
type RRBodyRRSIG = unit() {
    class_: uint16;
    timeToLive: uint32;
    dataLength: uint16;
    typeCov: uint16;
    alg: uint8;
    labels: uint8;
    OrigtimeToLive: uint32;
    SigExp: uint32;
    SigInception: uint32;
    keyTag: uint16;
    signName: Domain;
    signature: bytes &size=256;
};
type RRBodyDS = unit() {
    class_: uint16;
    timeToLive: uint32;
    dataLength: uint16;
    keyid: uint16;
    alg: uint8;
    digestType: uint8;
    digest: bytes &size=256;
};
type RRBodyNSEC3 = unit() { # copied from Tom's SCL code, which he is unsure of
    class_: uint16;
    timeToLive: uint32;
    dataLength: uint16;
    alg: uint8;
    flags: uint8;
    iterations: uint16;
    saltLength: uint8;
    hashlength: uint8;
    nexthash: bytes &size=self.hashlength;
    typeMap: Map;
};
