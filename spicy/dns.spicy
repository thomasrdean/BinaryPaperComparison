# Copyright (c) 2021 by the Zeek Project. See LICENSE for details.

module DNS;

import spicy;

public type PDU = unit {
    transactionId    : uint16;
    flags : bytes &size=2;

    numQuestion: uint16;
    numAnswer: uint16;
    numAuthority: uint16;
    numAdditional: uint16;

    question:   Query[self.numQuestion];
    answer:     ResourceRecord[self.numAnswer];
    authority:  ResourceRecord[self.numAuthority];
    additional: ResourceRecord[self.numAdditional];
    
    # on %done { print self; }
};

type Query = unit {
    name:  Domain;
    type_:  uint16;
    class: uint16;
};

type ResourceRecord = unit() {
    name:   Domain;
    type_:  uint16 &convert=RRType($$);
    class:  uint16;
    ttl:    uint32;
    dataLength:  uint16;

    switch ( self.type_ ) {
        RRType::A    -> address:    bytes &size=4;
        RRType::NS   -> nameServer:   Domain;
        RRType::CNAME-> cname: Domain;
        RRType::SOA  -> rr_body_soa:     RDataSOA;
        RRType::PTR  -> domainName: Domain;
        RRType::MX   -> rr_body_mx:      RDataMX;
        RRType::TXT  -> text:     PascalString;
        RRType::AAAA -> address:    bytes &size=16;
        # OPT
        # DS
        # KEY
        # RRSIG
        # NSEC3
        *            -> rdata:   Default;
    };
};

type Default = unit {
    bytes &size=self.dataLength;
    on % done {
        print "defaulted on ";
    }
};

type RRType = enum {
    A = 1,
    NS = 2,
    MD = 3,
    MF = 4,
    CNAME = 5,
    SOA = 6,
    MB = 7,
    MG = 8,
    MR = 9,
    NULL = 10,
    WKS = 11,
    PTR = 12,
    HINFO = 13,
    MINFO = 14,
    MX = 15,
    TXT = 16,
    AAAA = 28,
    NBS = 32,
    SRV= 33,
    A6 = 38,
    EDNS = 41
};

type RDataMX = unit {
    preference: uint16;
    name:        Domain;
};

type RDataSOA = unit {
    mname:      Domain;
    rname:      Domain;
    serial:     uint32;
    refresh:    uint32 &convert=cast<interval>($$);
    retry:      uint32 &convert=cast<interval>($$);
    expire:     uint32 &convert=cast<interval>($$);
    minimum:    uint32 &convert=cast<interval>($$);
};

type PascalString = unit {
    len: uint8;
    data: bytes &size=(self.len);
};

type Domain = unit {
    words: Label[] &until=($$.len.offset == 0 || $$.len.compressed != 0);
};

type Pointer = unit() {
    len: bitfield(16) {
        offset: 0..13;
        };
    };

type Label = unit() {
    len: bitfield(8) {
        offset: 0..5;
        compressed: 6..7;
    };

    switch ( self.len.compressed ) {
        0 ->    label: bytes &size=self.len.offset;
        3 ->    ptr: uint8;
    };
};
