FormatFuzzer:
https://uds-se.github.io/FormatFuzzer/
-very active community -> there's a research group in Germany
-uses 010 editor standard as grammars (BUT!, they said they tweak them a bit or something to make them work.... eww)
  -this comes with a nice editor and debugger to use while creating templates (grammars)
  -lots of templates around already (are they copyrighted?)
  -looks like c structs but with if, else, while, etc
  -very slick, haven't seen how to do TERMINATORs yet...
-can switch endianess mid-parse
-can parse inputs
-can create fuzzes
-can record decisions (alternatives taken) from parses and fuzzes and use them for fuzzes!
-mutating decision files can do mutations in a way that is always valid!!!
^I am skeptical of this... I'm working on doing this myself. Maybe I should just look at the code that writes out decisions to understand them better...

uses pfp to generate the c++ parser code
pfp uses py010parser to generate the AST
py010parser is a fork of pycparser
pycparser is for parsing c code (rather than .bt files)
^this whole chain seems a little janky considering necessity to me considering that there isn't a real reason for me to be set on the 010 standard...

AAaaah, the makefiles are really complicated (use automake and seem convuluted) :(
Also, there seems to be special stuff for their examples (e.g. gif) which makes me worried...
  -> yup: "Note that the .bt files provided in the repository generally target parsing files. They can be used for generating files, too; but they often lack exact information which parts of the input are required."
WAT: they copied the pfp project into their repo .... eew



"After each Template variable is declared, the current file position is moved forward. The current file position can be examined using the function FTell. By using the functions FSeek or FSkip, the current position can be moved around the file. This technique allows a file to be parsed out of order. Note that to read from a file without defining a variable, the functions ReadByte, ReadShort, ReadInt, etc. can be used (see I/O Functions)."



Note: I had to cast 192 to byte, and when I did that, it couldn't mine the value anymore.

FormatFuzzer has "generate" c code that is created from the .bt file. Since this code is used for parsing and fuzzing, I don't believe it is possible to lie about things in some ways because fuzzing is done by running the parser (and generating primatives instead of eating them) which means that fuzzing will break if constraints are not met. Therefore, it is not a flexible fuzzer. <- what it the primitive write funciton returns a different value than it writes?
